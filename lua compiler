-- compile function is c0
local a={}function a.luz()local b={}function b:make_getS(c)local d=c;return function()if not d then return nil end;local e=d;d=nil;return e end end;function b:init(f,e,g)if not f then return end;local h={}h.reader=f;h.data=e or""h.name=g;if not e or e==""then h.n=0 else h.n=#e end;h.p=0;return h end;function b:fill(h)local c=h.reader()h.data=c;if not c or c==""then return"EOZ"end;h.n,h.p=#c-1,1;return string.sub(c,1,1)end;function b:zgetc(h)local i,j=h.n,h.p+1;if i>0 then h.n,h.p=i-1,j;return string.sub(h.data,j,j)else return self:fill(h)end end;return b end;local k=a.luz()function a.lux()local b=a.luz()local l={}l.RESERVED=[[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]l.MAXSRC=80;l.MAX_INT=2147483645;l.LUA_QS="'%s'"l.LUA_COMPAT_LSTR=1;function l:init()local m,n={},{}for o in string.gmatch(self.RESERVED,"[^\n]+")do local p,p,q,r=string.find(o,"(%S+)%s+(%S+)")m[q]=r;n[r]=q end;self.tokens=m;self["enums"]=n end;function l:chunkid(s,t)local u;local v=string.sub(s,1,1)if v=="="then u=string.sub(s,2,t)else if v=="@"then s=string.sub(s,2)t=t-#" '...' "local w=#s;u=""if w>t then s=string.sub(s,1+w-t)u=u.."..."end;u=u..s else local x=string.find(s,"[\n\r]")x=x and x-1 or#s;t=t-#" [string \"...\"] "if x>t then x=t end;u="[string \""if x<#s then u=u..string.sub(s,1,x).."..."else u=u..s end;u=u.."\"]"end end;return u end;function l:token2str(y,z)if string.sub(z,1,3)~="TK_"then if string.find(z,"%c")then return string.format("char(%d)",string.byte(z))end;return z else end;return self.tokens[z]end;function l:lexerror(y,A,z)local function B(y,z)if z=="TK_NAME"or z=="TK_STRING"or z=="TK_NUMBER"then return y.buff else return self:token2str(y,z)end end;local c=self:chunkid(y.source,self.MAXSRC)local A=string.format("%s:%d: %s",c,y.linenumber,A)if z then A=string.format("%s near "..self.LUA_QS,A,B(y,z))end;error(A)end;function l:syntaxerror(y,A)self:lexerror(y,A,y.t.token)end;function l:currIsNewline(y)return y.current=="\n"or y.current=="\r"end;function l:inclinenumber(y)local C=y.current;self:nextc(y)if self:currIsNewline(y)and y.current~=C then self:nextc(y)end;y.linenumber=y.linenumber+1;if y.linenumber>=self.MAX_INT then self:syntaxerror(y,"chunk has too many lines")end end;function l:setinput(D,y,h,s)if not y then y={}end;if not y.lookahead then y.lookahead={}end;if not y.t then y.t={}end;y.decpoint="."y.L=D;y.lookahead.token="TK_EOS"y.z=h;y.fs=nil;y.linenumber=1;y.lastline=1;y.source=s;self:nextc(y)end;function l:check_next(y,E)if not string.find(E,y.current,1,1)then return false end;self:save_and_next(y)return true end;function l:next(y)y.lastline=y.linenumber;if y.lookahead.token~="TK_EOS"then y.t.seminfo=y.lookahead.seminfo;y.t.token=y.lookahead.token;y.lookahead.token="TK_EOS"else y.t.token=self:llex(y,y.t)end end;function l:lookahead(y)y.lookahead.token=self:llex(y,y.lookahead)end;function l:nextc(y)local F=b:zgetc(y.z)y.current=F;return F end;function l:save(y,F)local c=y.buff;y.buff=c..F end;function l:save_and_next(y)self:save(y,y.current)return self:nextc(y)end;function l:str2d(G)local H=tonumber(G)if H then return H end;if string.lower(string.sub(G,1,2))=="0x"then H=tonumber(G,16)if H then return H end end;return nil end;function l:buffreplace(y,I,J)local H,c="",y.buff;for j=1,#c do local F=string.sub(c,j,j)if F==I then F=J end;H=H..F end;y.buff=H end;function l:trydecpoint(y,K)local C=y.decpoint;self:buffreplace(y,C,y.decpoint)local L=self:str2d(y.buff)K.seminfo=L;if not L then self:buffreplace(y,y.decpoint,".")self:lexerror(y,"malformed number","TK_NUMBER")end end;function l:read_numeral(y,K)repeat self:save_and_next(y)until string.find(y.current,"%D")and y.current~="."if self:check_next(y,"Ee")then self:check_next(y,"+-")end;while string.find(y.current,"^%w$")or y.current=="_"do self:save_and_next(y)end;self:buffreplace(y,".",y.decpoint)local L=self:str2d(y.buff)K.seminfo=L;if not L then self:trydecpoint(y,K)end end;function l:skip_sep(y)local M=0;local G=y.current;self:save_and_next(y)while y.current=="="do self:save_and_next(y)M=M+1 end;return y.current==G and M or-M-1 end;function l:read_long_string(y,K,N)local O=0;self:save_and_next(y)if self:currIsNewline(y)then self:inclinenumber(y)end;while true do local F=y.current;if F=="EOZ"then self:lexerror(y,K and"unfinished long string"or"unfinished long comment","TK_EOS")elseif F=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(y)==N then self:save_and_next(y)O=O+1;if self.LUA_COMPAT_LSTR==1 then if N==0 then self:lexerror(y,"nesting of [[...]] is deprecated","[")end end end end elseif F=="]"then if self:skip_sep(y)==N then self:save_and_next(y)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then O=O-1;if N==0 and O>=0 then break end end;break end elseif self:currIsNewline(y)then self:save(y,"\n")self:inclinenumber(y)if not K then y.buff=""end else if K then self:save_and_next(y)else self:nextc(y)end end end;if K then local j=3+N;K.seminfo=string.sub(y.buff,j,-j)end end;function l:read_string(y,P,K)self:save_and_next(y)while y.current~=P do local F=y.current;if F=="EOZ"then self:lexerror(y,"unfinished string","TK_EOS")elseif self:currIsNewline(y)then self:lexerror(y,"unfinished string","TK_STRING")elseif F=="\\"then F=self:nextc(y)if self:currIsNewline(y)then self:save(y,"\n")self:inclinenumber(y)elseif F~="EOZ"then local Q=string.find("abfnrtv",F,1,1)if Q then self:save(y,string.sub("\a\b\f\n\r\t\v",Q,Q))self:nextc(y)elseif not string.find(F,"%d")then self:save_and_next(y)else F,Q=0,0;repeat F=10*F+y.current;self:nextc(y)Q=Q+1 until Q>=3 or not string.find(y.current,"%d")if F>255 then self:lexerror(y,"escape sequence too large","TK_STRING")end;self:save(y,string.char(F))end end else self:save_and_next(y)end end;self:save_and_next(y)K.seminfo=string.sub(y.buff,2,-2)end;function l:llex(y,K)y.buff=""while true do local F=y.current;if self:currIsNewline(y)then self:inclinenumber(y)elseif F=="-"then F=self:nextc(y)if F~="-"then return"-"end;local N=-1;if self:nextc(y)=='['then N=self:skip_sep(y)y.buff=""end;if N>=0 then self:read_long_string(y,nil,N)y.buff=""else while not self:currIsNewline(y)and y.current~="EOZ"do self:nextc(y)end end elseif F=="["then local N=self:skip_sep(y)if N>=0 then self:read_long_string(y,K,N)return"TK_STRING"elseif N==-1 then return"["else self:lexerror(y,"invalid long string delimiter","TK_STRING")end elseif F=="="then F=self:nextc(y)if F~="="then return"="else self:nextc(y)return"TK_EQ"end elseif F=="<"then F=self:nextc(y)if F~="="then return"<"else self:nextc(y)return"TK_LE"end elseif F==">"then F=self:nextc(y)if F~="="then return">"else self:nextc(y)return"TK_GE"end elseif F=="~"then F=self:nextc(y)if F~="="then return"~"else self:nextc(y)return"TK_NE"end elseif F=="\""or F=="'"then self:read_string(y,F,K)return"TK_STRING"elseif F=="."then F=self:save_and_next(y)if self:check_next(y,".")then if self:check_next(y,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(F,"%d")then return"."else self:read_numeral(y,K)return"TK_NUMBER"end elseif F=="EOZ"then return"TK_EOS"else if string.find(F,"%s")then self:nextc(y)elseif string.find(F,"%d")then self:read_numeral(y,K)return"TK_NUMBER"elseif string.find(F,"[_%a]")then repeat F=self:save_and_next(y)until F=="EOZ"or not string.find(F,"[_%w]")local R=y.buff;local q=self["enums"][R]if q then return q end;K.seminfo=R;return"TK_NAME"else self:nextc(y)return F end end end end;return l end;local S=a.lux()function a.lup()local T={}T.OpMode={iABC=0,iABx=1,iAsBx=2}T.SIZE_C=9;T.SIZE_B=9;T.SIZE_Bx=T.SIZE_C+T.SIZE_B;T.SIZE_A=8;T.SIZE_OP=6;T.POS_OP=0;T.POS_A=T.POS_OP+T.SIZE_OP;T.POS_C=T.POS_A+T.SIZE_A;T.POS_B=T.POS_C+T.SIZE_C;T.POS_Bx=T.POS_C;T.MAXARG_Bx=math.ldexp(1,T.SIZE_Bx)-1;T.MAXARG_sBx=math.floor(T.MAXARG_Bx/2)T.MAXARG_A=math.ldexp(1,T.SIZE_A)-1;T.MAXARG_B=math.ldexp(1,T.SIZE_B)-1;T.MAXARG_C=math.ldexp(1,T.SIZE_C)-1;function T:GET_OPCODE(Q)return self.ROpCode[Q.OP]end;function T:SET_OPCODE(Q,U)Q.OP=self.OpCode[U]end;function T:GETARG_A(Q)return Q.A end;function T:SETARG_A(Q,V)Q.A=V end;function T:GETARG_B(Q)return Q.B end;function T:SETARG_B(Q,d)Q.B=d end;function T:GETARG_C(Q)return Q.C end;function T:SETARG_C(Q,d)Q.C=d end;function T:GETARG_Bx(Q)return Q.Bx end;function T:SETARG_Bx(Q,d)Q.Bx=d end;function T:GETARG_sBx(Q)return Q.Bx-self.MAXARG_sBx end;function T:SETARG_sBx(Q,d)Q.Bx=d+self.MAXARG_sBx end;function T:CREATE_ABC(U,W,d,F)return{OP=self.OpCode[U],A=W,B=d,C=F}end;function T:CREATE_ABx(U,W,X)return{OP=self.OpCode[U],A=W,Bx=X}end;function T:CREATE_Inst(F)local U=F%64;F=(F-U)/64;local W=F%256;F=(F-W)/256;return self:CREATE_ABx(U,W,F)end;function T:Instruction(Q)if Q.Bx then Q.C=Q.Bx%512;Q.B=(Q.Bx-Q.C)/512 end;local Y=Q.A*64+Q.OP;local Z=Y%256;Y=Q.C*64+(Y-Z)/256;local _=Y%256;Y=Q.B*128+(Y-_)/256;local a0=Y%256;local a1=(Y-a0)/256;return string.char(Z,_,a0,a1)end;function T:DecodeInst(a2)local a3=string.byte;local Q={}local Y=a3(a2,1)local a4=Y%64;Q.OP=a4;Y=a3(a2,2)*4+(Y-a4)/64;local W=Y%256;Q.A=W;Y=a3(a2,3)*4+(Y-W)/256;local F=Y%512;Q.C=F;Q.B=a3(a2,4)*2+(Y-F)/512;local a5=self.OpMode[tonumber(string.sub(self.opmodes[a4+1],7,7))]if a5~="iABC"then Q.Bx=Q.B*512+Q.C end;return Q end;T.BITRK=math.ldexp(1,T.SIZE_B-1)function T:ISK(a2)return a2>=self.BITRK end;function T:INDEXK(a2)return a2-self.BITRK end;T.MAXINDEXRK=T.BITRK-1;function T:RKASK(a2)return a2+self.BITRK end;T.NO_REG=T.MAXARG_A;T.opnames={}T.OpCode={}T.ROpCode={}local Q=0;for o in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],"%S+")do local i="OP_"..o;T.opnames[Q]=o;T.OpCode[i]=Q;T.ROpCode[Q]=i;Q=Q+1 end;T.NUM_OPCODES=Q;T.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function T:getOpMode(a6)return self.opmodes[self.OpCode[a6]]%4 end;function T:getBMode(a6)return math.floor(self.opmodes[self.OpCode[a6]]/16)%4 end;function T:getCMode(a6)return math.floor(self.opmodes[self.OpCode[a6]]/4)%4 end;function T:testAMode(a6)return math.floor(self.opmodes[self.OpCode[a6]]/64)%2 end;function T:testTMode(a6)return math.floor(self.opmodes[self.OpCode[a6]]/128)end;T.LFIELDS_PER_FLUSH=50;local function a5(a7,W,d,F,a6)local T=T;return a7*128+W*64+T.OpArgMask[d]*16+T.OpArgMask[F]*4+T.OpMode[a6]end;T.opmodes={a5(0,1,"OpArgK","OpArgN","iABx"),a5(0,1,"OpArgU","OpArgU","iABC"),a5(0,1,"OpArgR","OpArgN","iABC"),a5(0,1,"OpArgU","OpArgN","iABC"),a5(0,1,"OpArgK","OpArgN","iABx"),a5(0,1,"OpArgR","OpArgK","iABC"),a5(0,0,"OpArgK","OpArgN","iABx"),a5(0,0,"OpArgU","OpArgN","iABC"),a5(0,0,"OpArgK","OpArgK","iABC"),a5(0,1,"OpArgU","OpArgU","iABC"),a5(0,1,"OpArgR","OpArgK","iABC"),a5(0,1,"OpArgK","OpArgK","iABC"),a5(0,1,"OpArgK","OpArgK","iABC"),a5(0,1,"OpArgK","OpArgK","iABC"),a5(0,1,"OpArgK","OpArgK","iABC"),a5(0,1,"OpArgK","OpArgK","iABC"),a5(0,1,"OpArgK","OpArgK","iABC"),a5(0,1,"OpArgR","OpArgN","iABC"),a5(0,1,"OpArgR","OpArgN","iABC"),a5(0,1,"OpArgR","OpArgN","iABC"),a5(0,1,"OpArgR","OpArgR","iABC"),a5(0,0,"OpArgR","OpArgN","iAsBx"),a5(1,0,"OpArgK","OpArgK","iABC"),a5(1,0,"OpArgK","OpArgK","iABC"),a5(1,0,"OpArgK","OpArgK","iABC"),a5(1,1,"OpArgR","OpArgU","iABC"),a5(1,1,"OpArgR","OpArgU","iABC"),a5(0,1,"OpArgU","OpArgU","iABC"),a5(0,1,"OpArgU","OpArgU","iABC"),a5(0,0,"OpArgU","OpArgN","iABC"),a5(0,1,"OpArgR","OpArgN","iAsBx"),a5(0,1,"OpArgR","OpArgN","iAsBx"),a5(1,0,"OpArgN","OpArgU","iABC"),a5(0,0,"OpArgU","OpArgU","iABC"),a5(0,0,"OpArgN","OpArgN","iABC"),a5(0,1,"OpArgU","OpArgN","iABx"),a5(0,1,"OpArgU","OpArgN","iABC")}T.opmodes[0]=a5(0,1,"OpArgR","OpArgN","iABC")return T end;function a.luk()local a8={}local T=a.lup()local l=a.lux()l:init()a8.MAXSTACK=250;function a8:ttisnumber(U)if U then return type(U.value)=="number"else return false end end;function a8:nvalue(U)return U.value end;function a8:setnilvalue(U)U.value=nil end;function a8:setsvalue(U,a2)U.value=a2 end;a8.setnvalue=a8.setsvalue;a8.sethvalue=a8.setsvalue;a8.setbvalue=a8.setsvalue;function a8:numadd(W,d)return W+d end;function a8:numsub(W,d)return W-d end;function a8:nummul(W,d)return W*d end;function a8:numdiv(W,d)return W/d end;function a8:nummod(W,d)return W%d end;function a8:numpow(W,d)return W^d end;function a8:numunm(W)return-W end;function a8:numisnan(W)return not W==W end;a8.NO_JUMP=-1;a8.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}a8.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function a8:getcode(a9,aa)return a9.f.code[aa.info]end;function a8:codeAsBx(a9,U,ab,ac)return self:codeABx(a9,U,ab,ac+T.MAXARG_sBx)end;function a8:setmultret(a9,aa)self:setreturns(a9,aa,luaY.LUA_MULTRET)end;function a8:hasjumps(aa)return aa.t~=aa.f end;function a8:isnumeral(aa)return aa.k=="VKNUM"and aa.t==self.NO_JUMP and aa.f==self.NO_JUMP end;function a8:_nil(a9,I,i)if a9.pc>a9.lasttarget then if a9.pc==0 then if I>=a9.nactvar then return end else local ad=a9.f.code[a9.pc-1]if T:GET_OPCODE(ad)=="OP_LOADNIL"then local ae=T:GETARG_A(ad)local af=T:GETARG_B(ad)if ae<=I and I<=af+1 then if I+i-1>af then T:SETARG_B(ad,I+i-1)end;return end end end end;self:codeABC(a9,"OP_LOADNIL",I,I+i-1,0)end;function a8:jump(a9)local ag=a9.jpc;a9.jpc=self.NO_JUMP;local ah=self:codeAsBx(a9,"OP_JMP",0,self.NO_JUMP)ah=self:concat(a9,ah,ag)return ah end;function a8:ret(a9,v,ai)self:codeABC(a9,"OP_RETURN",v,ai+1,0)end;function a8:condjump(a9,a4,ab,aj,ak)self:codeABC(a9,a4,ab,aj,ak)return self:jump(a9)end;function a8:fixjump(a9,al,am)local an=a9.f.code[al]local ao=am-(al+1)assert(am~=self.NO_JUMP)if math.abs(ao)>T.MAXARG_sBx then l:syntaxerror(a9.ls,"control structure too long")end;T:SETARG_sBx(an,ao)end;function a8:getlabel(a9)a9.lasttarget=a9.pc;return a9.pc end;function a8:getjump(a9,al)local ao=T:GETARG_sBx(a9.f.code[al])if ao==self.NO_JUMP then return self.NO_JUMP else return al+1+ao end end;function a8:getjumpcontrol(a9,al)local ap=a9.f.code[al]local aq=a9.f.code[al-1]if al>=1 and T:testTMode(T:GET_OPCODE(aq))~=0 then return aq else return ap end end;function a8:need_value(a9,ar)while ar~=self.NO_JUMP do local Q=self:getjumpcontrol(a9,ar)if T:GET_OPCODE(Q)~="OP_TESTSET"then return true end;ar=self:getjump(a9,ar)end;return false end;function a8:patchtestreg(a9,as,at)local Q=self:getjumpcontrol(a9,as)if T:GET_OPCODE(Q)~="OP_TESTSET"then return false end;if at~=T.NO_REG and at~=T:GETARG_B(Q)then T:SETARG_A(Q,at)else T:SET_OPCODE(Q,"OP_TEST")local d=T:GETARG_B(Q)T:SETARG_A(Q,d)T:SETARG_B(Q,0)end;return true end;function a8:removevalues(a9,ar)while ar~=self.NO_JUMP do self:patchtestreg(a9,ar,T.NO_REG)ar=self:getjump(a9,ar)end end;function a8:patchlistaux(a9,ar,au,at,av)while ar~=self.NO_JUMP do local aw=self:getjump(a9,ar)if self:patchtestreg(a9,ar,at)then self:fixjump(a9,ar,au)else self:fixjump(a9,ar,av)end;ar=aw end end;function a8:dischargejpc(a9)self:patchlistaux(a9,a9.jpc,a9.pc,T.NO_REG,a9.pc)a9.jpc=self.NO_JUMP end;function a8:patchlist(a9,ar,ax)if ax==a9.pc then self:patchtohere(a9,ar)else assert(ax<a9.pc)self:patchlistaux(a9,ar,ax,T.NO_REG,ax)end end;function a8:patchtohere(a9,ar)self:getlabel(a9)a9.jpc=self:concat(a9,a9.jpc,ar)end;function a8:concat(a9,ay,az)if az==self.NO_JUMP then return ay elseif ay==self.NO_JUMP then return az else local ar=ay;local aw=self:getjump(a9,ar)while aw~=self.NO_JUMP do ar=aw;aw=self:getjump(a9,ar)end;self:fixjump(a9,ar,az)end;return ay end;function a8:checkstack(a9,i)local aA=a9.freereg+i;if aA>a9.f.maxstacksize then if aA>=self.MAXSTACK then l:syntaxerror(a9.ls,"function or expression too complex")end;a9.f.maxstacksize=aA end end;function a8:reserveregs(a9,i)self:checkstack(a9,i)a9.freereg=a9.freereg+i end;function a8:freereg(a9,at)if not T:ISK(at)and at>=a9.nactvar then a9.freereg=a9.freereg-1;assert(at==a9.freereg)end end;function a8:freeexp(a9,aa)if aa.k=="VNONRELOC"then self:freereg(a9,aa.info)end end;function a8:addk(a9,aB,o)local D=a9.L;local aC=a9.h[aB.value]local aD=a9.f;if self:ttisnumber(aC)then return self:nvalue(aC)else aC={}self:setnvalue(aC,a9.nk)a9.h[aB.value]=aC;luaY:growvector(D,aD.k,a9.nk,aD.sizek,nil,T.MAXARG_Bx,"constant table overflow")aD.k[a9.nk]=o;local aE=a9.nk;a9.nk=a9.nk+1;return aE end end;function a8:stringK(a9,G)local U={}self:setsvalue(U,G)return self:addk(a9,U,U)end;function a8:numberK(a9,aF)local U={}self:setnvalue(U,aF)return self:addk(a9,U,U)end;function a8:boolK(a9,d)local U={}self:setbvalue(U,d)return self:addk(a9,U,U)end;function a8:nilK(a9)local aB,o={},{}self:setnilvalue(o)self:sethvalue(aB,a9.h)return self:addk(a9,aB,o)end;function a8:setreturns(a9,aa,aG)if aa.k=="VCALL"then T:SETARG_C(self:getcode(a9,aa),aG+1)elseif aa.k=="VVARARG"then T:SETARG_B(self:getcode(a9,aa),aG+1)T:SETARG_A(self:getcode(a9,aa),a9.freereg)a8:reserveregs(a9,1)end end;function a8:setoneret(a9,aa)if aa.k=="VCALL"then aa.k="VNONRELOC"aa.info=T:GETARG_A(self:getcode(a9,aa))elseif aa.k=="VVARARG"then T:SETARG_B(self:getcode(a9,aa),2)aa.k="VRELOCABLE"end end;function a8:dischargevars(a9,aa)local aB=aa.k;if aB=="VLOCAL"then aa.k="VNONRELOC"elseif aB=="VUPVAL"then aa.info=self:codeABC(a9,"OP_GETUPVAL",0,aa.info,0)aa.k="VRELOCABLE"elseif aB=="VGLOBAL"then aa.info=self:codeABx(a9,"OP_GETGLOBAL",0,aa.info)aa.k="VRELOCABLE"elseif aB=="VINDEXED"then self:freereg(a9,aa.aux)self:freereg(a9,aa.info)aa.info=self:codeABC(a9,"OP_GETTABLE",0,aa.info,aa.aux)aa.k="VRELOCABLE"elseif aB=="VVARARG"or aB=="VCALL"then self:setoneret(a9,aa)else end end;function a8:code_label(a9,ab,d,aH)self:getlabel(a9)return self:codeABC(a9,"OP_LOADBOOL",ab,d,aH)end;function a8:discharge2reg(a9,aa,at)self:dischargevars(a9,aa)local aB=aa.k;if aB=="VNIL"then self:_nil(a9,at,1)elseif aB=="VFALSE"or aB=="VTRUE"then self:codeABC(a9,"OP_LOADBOOL",at,aa.k=="VTRUE"and 1 or 0,0)elseif aB=="VK"then self:codeABx(a9,"OP_LOADK",at,aa.info)elseif aB=="VKNUM"then self:codeABx(a9,"OP_LOADK",at,self:numberK(a9,aa.nval))elseif aB=="VRELOCABLE"then local al=self:getcode(a9,aa)T:SETARG_A(al,at)elseif aB=="VNONRELOC"then if at~=aa.info then self:codeABC(a9,"OP_MOVE",at,aa.info,0)end else assert(aa.k=="VVOID"or aa.k=="VJMP")return end;aa.info=at;aa.k="VNONRELOC"end;function a8:discharge2anyreg(a9,aa)if aa.k~="VNONRELOC"then self:reserveregs(a9,1)self:discharge2reg(a9,aa,a9.freereg-1)end end;function a8:exp2reg(a9,aa,at)self:discharge2reg(a9,aa,at)if aa.k=="VJMP"then aa.t=self:concat(a9,aa.t,aa.info)end;if self:hasjumps(aa)then local aI;local aJ=self.NO_JUMP;local aK=self.NO_JUMP;if self:need_value(a9,aa.t)or self:need_value(a9,aa.f)then local aL=aa.k=="VJMP"and self.NO_JUMP or self:jump(a9)aJ=self:code_label(a9,at,0,1)aK=self:code_label(a9,at,1,0)self:patchtohere(a9,aL)end;aI=self:getlabel(a9)self:patchlistaux(a9,aa.f,aI,at,aJ)self:patchlistaux(a9,aa.t,aI,at,aK)end;aa.f,aa.t=self.NO_JUMP,self.NO_JUMP;aa.info=at;aa.k="VNONRELOC"end;function a8:exp2nextreg(a9,aa)self:dischargevars(a9,aa)self:freeexp(a9,aa)self:reserveregs(a9,1)self:exp2reg(a9,aa,a9.freereg-1)end;function a8:exp2anyreg(a9,aa)self:dischargevars(a9,aa)if aa.k=="VNONRELOC"then if not self:hasjumps(aa)then return aa.info end;if aa.info>=a9.nactvar then self:exp2reg(a9,aa,aa.info)return aa.info end end;self:exp2nextreg(a9,aa)return aa.info end;function a8:exp2val(a9,aa)if self:hasjumps(aa)then self:exp2anyreg(a9,aa)else self:dischargevars(a9,aa)end end;function a8:exp2RK(a9,aa)self:exp2val(a9,aa)local aB=aa.k;if aB=="VKNUM"or aB=="VTRUE"or aB=="VFALSE"or aB=="VNIL"then if a9.nk<=T.MAXINDEXRK then if aa.k=="VNIL"then aa.info=self:nilK(a9)else aa.info=aa.k=="VKNUM"and self:numberK(a9,aa.nval)or self:boolK(a9,aa.k=="VTRUE")end;aa.k="VK"return T:RKASK(aa.info)end elseif aB=="VK"then if aa.info<=T.MAXINDEXRK then return T:RKASK(aa.info)end else end;return self:exp2anyreg(a9,aa)end;function a8:storevar(a9,aM,aN)local aB=aM.k;if aB=="VLOCAL"then self:freeexp(a9,aN)self:exp2reg(a9,aN,aM.info)return elseif aB=="VUPVAL"then local aa=self:exp2anyreg(a9,aN)self:codeABC(a9,"OP_SETUPVAL",aa,aM.info,0)elseif aB=="VGLOBAL"then local aa=self:exp2anyreg(a9,aN)self:codeABx(a9,"OP_SETGLOBAL",aa,aM.info)elseif aB=="VINDEXED"then local aa=self:exp2RK(a9,aN)self:codeABC(a9,"OP_SETTABLE",aM.info,aM.aux,aa)else assert(0)end;self:freeexp(a9,aN)end;function a8:_self(a9,aa,aO)self:exp2anyreg(a9,aa)self:freeexp(a9,aa)local aP=a9.freereg;self:reserveregs(a9,2)self:codeABC(a9,"OP_SELF",aP,aa.info,self:exp2RK(a9,aO))self:freeexp(a9,aO)aa.info=aP;aa.k="VNONRELOC"end;function a8:invertjump(a9,aa)local al=self:getjumpcontrol(a9,aa.info)assert(T:testTMode(T:GET_OPCODE(al))~=0 and T:GET_OPCODE(al)~="OP_TESTSET"and T:GET_OPCODE(al)~="OP_TEST")T:SETARG_A(al,T:GETARG_A(al)==0 and 1 or 0)end;function a8:jumponcond(a9,aa,aQ)if aa.k=="VRELOCABLE"then local aR=self:getcode(a9,aa)if T:GET_OPCODE(aR)=="OP_NOT"then a9.pc=a9.pc-1;return self:condjump(a9,"OP_TEST",T:GETARG_B(aR),0,aQ and 0 or 1)end end;self:discharge2anyreg(a9,aa)self:freeexp(a9,aa)return self:condjump(a9,"OP_TESTSET",T.NO_REG,aa.info,aQ and 1 or 0)end;function a8:goiftrue(a9,aa)local al;self:dischargevars(a9,aa)local aB=aa.k;if aB=="VK"or aB=="VKNUM"or aB=="VTRUE"then al=self.NO_JUMP elseif aB=="VFALSE"then al=self:jump(a9)elseif aB=="VJMP"then self:invertjump(a9,aa)al=aa.info else al=self:jumponcond(a9,aa,false)end;aa.f=self:concat(a9,aa.f,al)self:patchtohere(a9,aa.t)aa.t=self.NO_JUMP end;function a8:goiffalse(a9,aa)local al;self:dischargevars(a9,aa)local aB=aa.k;if aB=="VNIL"or aB=="VFALSE"then al=self.NO_JUMP elseif aB=="VTRUE"then al=self:jump(a9)elseif aB=="VJMP"then al=aa.info else al=self:jumponcond(a9,aa,true)end;aa.t=self:concat(a9,aa.t,al)self:patchtohere(a9,aa.f)aa.f=self.NO_JUMP end;function a8:codenot(a9,aa)self:dischargevars(a9,aa)local aB=aa.k;if aB=="VNIL"or aB=="VFALSE"then aa.k="VTRUE"elseif aB=="VK"or aB=="VKNUM"or aB=="VTRUE"then aa.k="VFALSE"elseif aB=="VJMP"then self:invertjump(a9,aa)elseif aB=="VRELOCABLE"or aB=="VNONRELOC"then self:discharge2anyreg(a9,aa)self:freeexp(a9,aa)aa.info=self:codeABC(a9,"OP_NOT",0,aa.info,0)aa.k="VRELOCABLE"else assert(0)end;aa.f,aa.t=aa.t,aa.f;self:removevalues(a9,aa.f)self:removevalues(a9,aa.t)end;function a8:indexed(a9,a7,aB)a7.aux=self:exp2RK(a9,aB)a7.k="VINDEXED"end;function a8:constfolding(a4,aS,aT)local aF;if not self:isnumeral(aS)or not self:isnumeral(aT)then return false end;local aU=aS.nval;local aV=aT.nval;if a4=="OP_ADD"then aF=self:numadd(aU,aV)elseif a4=="OP_SUB"then aF=self:numsub(aU,aV)elseif a4=="OP_MUL"then aF=self:nummul(aU,aV)elseif a4=="OP_DIV"then if aV==0 then return false end;aF=self:numdiv(aU,aV)elseif a4=="OP_MOD"then if aV==0 then return false end;aF=self:nummod(aU,aV)elseif a4=="OP_POW"then aF=self:numpow(aU,aV)elseif a4=="OP_UNM"then aF=self:numunm(aU)elseif a4=="OP_LEN"then return false else assert(0)aF=0 end;if self:numisnan(aF)then return false end;aS.nval=aF;return true end;function a8:codearith(a9,a4,aS,aT)if self:constfolding(a4,aS,aT)then return else local aW=a4~="OP_UNM"and a4~="OP_LEN"and self:exp2RK(a9,aT)or 0;local aX=self:exp2RK(a9,aS)if aX>aW then self:freeexp(a9,aS)self:freeexp(a9,aT)else self:freeexp(a9,aT)self:freeexp(a9,aS)end;aS.info=self:codeABC(a9,a4,0,aX,aW)aS.k="VRELOCABLE"end end;function a8:codecomp(a9,a4,aQ,aS,aT)local aX=self:exp2RK(a9,aS)local aW=self:exp2RK(a9,aT)self:freeexp(a9,aT)self:freeexp(a9,aS)if aQ==0 and a4~="OP_EQ"then aX,aW=aW,aX;aQ=1 end;aS.info=self:condjump(a9,a4,aQ,aX,aW)aS.k="VJMP"end;function a8:prefix(a9,a4,aa)local aT={}aT.t,aT.f=self.NO_JUMP,self.NO_JUMP;aT.k="VKNUM"aT.nval=0;if a4=="OPR_MINUS"then if not self:isnumeral(aa)then self:exp2anyreg(a9,aa)end;self:codearith(a9,"OP_UNM",aa,aT)elseif a4=="OPR_NOT"then self:codenot(a9,aa)elseif a4=="OPR_LEN"then self:exp2anyreg(a9,aa)self:codearith(a9,"OP_LEN",aa,aT)else assert(0)end end;function a8:infix(a9,a4,o)if a4=="OPR_AND"then self:goiftrue(a9,o)elseif a4=="OPR_OR"then self:goiffalse(a9,o)elseif a4=="OPR_CONCAT"then self:exp2nextreg(a9,o)elseif a4=="OPR_ADD"or a4=="OPR_SUB"or a4=="OPR_MUL"or a4=="OPR_DIV"or a4=="OPR_MOD"or a4=="OPR_POW"then if not self:isnumeral(o)then self:exp2RK(a9,o)end else self:exp2RK(a9,o)end end;a8.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}a8.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}a8.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function a8:posfix(a9,a4,aS,aT)local function aY(aS,aT)aS.k=aT.k;aS.info=aT.info;aS.aux=aT.aux;aS.nval=aT.nval;aS.t=aT.t;aS.f=aT.f end;if a4=="OPR_AND"then assert(aS.t==self.NO_JUMP)self:dischargevars(a9,aT)aT.f=self:concat(a9,aT.f,aS.f)aY(aS,aT)elseif a4=="OPR_OR"then assert(aS.f==self.NO_JUMP)self:dischargevars(a9,aT)aT.t=self:concat(a9,aT.t,aS.t)aY(aS,aT)elseif a4=="OPR_CONCAT"then self:exp2val(a9,aT)if aT.k=="VRELOCABLE"and T:GET_OPCODE(self:getcode(a9,aT))=="OP_CONCAT"then assert(aS.info==T:GETARG_B(self:getcode(a9,aT))-1)self:freeexp(a9,aS)T:SETARG_B(self:getcode(a9,aT),aS.info)aS.k="VRELOCABLE"aS.info=aT.info else self:exp2nextreg(a9,aT)self:codearith(a9,"OP_CONCAT",aS,aT)end else local aZ=self.arith_op[a4]if aZ then self:codearith(a9,aZ,aS,aT)else local a_=self.comp_op[a4]if a_ then self:codecomp(a9,a_,self.comp_cond[a4],aS,aT)else assert(0)end end end end;function a8:fixline(a9,b0)a9.f.lineinfo[a9.pc-1]=b0 end;function a8:code(a9,Q,b0)local aD=a9.f;self:dischargejpc(a9)luaY:growvector(a9.L,aD.code,a9.pc,aD.sizecode,nil,luaY.MAX_INT,"code size overflow")aD.code[a9.pc]=Q;luaY:growvector(a9.L,aD.lineinfo,a9.pc,aD.sizelineinfo,nil,luaY.MAX_INT,"code size overflow")aD.lineinfo[a9.pc]=b0;local al=a9.pc;a9.pc=a9.pc+1;return al end;function a8:codeABC(a9,U,W,d,F)assert(T:getOpMode(U)==T.OpMode.iABC)assert(T:getBMode(U)~=T.OpArgMask.OpArgN or d==0)assert(T:getCMode(U)~=T.OpArgMask.OpArgN or F==0)return self:code(a9,T:CREATE_ABC(U,W,d,F),a9.ls.lastline)end;function a8:codeABx(a9,U,W,X)assert(T:getOpMode(U)==T.OpMode.iABx or T:getOpMode(U)==T.OpMode.iAsBx)assert(T:getCMode(U)==T.OpArgMask.OpArgN)return self:code(a9,T:CREATE_ABx(U,W,X),a9.ls.lastline)end;function a8:setlist(a9,b1,b2,b3)local F=math.floor((b2-1)/T.LFIELDS_PER_FLUSH)+1;local d=b3==luaY.LUA_MULTRET and 0 or b3;assert(b3~=0)if F<=T.MAXARG_C then self:codeABC(a9,"OP_SETLIST",b1,d,F)else self:codeABC(a9,"OP_SETLIST",b1,d,0)self:code(a9,T:CREATE_Inst(F),a9.ls.lastline)end;a9.freereg=b1+1 end;return function(W)luaY=W;return a8 end end;function a.luy()local luaY={}local l=a.lux()local a8=a.luk()(luaY)local T=a.lup()l:init()luaY.LUA_QS=l.LUA_QS or"'%s'"luaY.SHRT_MAX=32767;luaY.LUAI_MAXVARS=200;luaY.LUAI_MAXUPVALUES=60;luaY.MAX_INT=l.MAX_INT or 2147483645;luaY.LUAI_MAXCCALLS=200;luaY.VARARG_HASARG=1;luaY.HASARG_MASK=2;luaY.VARARG_ISVARARG=2;luaY.VARARG_NEEDSARG=4;luaY.LUA_MULTRET=-1;function luaY:LUA_QL(a2)return"'"..a2 .."'"end;function luaY:growvector(D,o,b2,b4,a7,b5,aa)if b2>=b5 then error(aa)end end;function luaY:newproto(D)local aD={}aD.k={}aD.sizek=0;aD.p={}aD.sizep=0;aD.code={}aD.sizecode=0;aD.sizelineinfo=0;aD.sizeupvalues=0;aD.nups=0;aD.upvalues={}aD.numparams=0;aD.is_vararg=0;aD.maxstacksize=0;aD.lineinfo={}aD.sizelocvars=0;aD.locvars={}aD.lineDefined=0;aD.lastlinedefined=0;aD.source=nil;return aD end;function luaY:int2fb(a2)local aa=0;while a2>=16 do a2=math.floor((a2+1)/2)aa=aa+1 end;if a2<8 then return a2 else return(aa+1)*8+a2-8 end end;function luaY:hasmultret(aB)return aB=="VCALL"or aB=="VVARARG"end;function luaY:getlocvar(a9,Q)return a9.f.locvars[a9.actvar[Q]]end;function luaY:checklimit(a9,o,w,a6)if o>w then self:errorlimit(a9,w,a6)end end;function luaY:anchor_token(y)if y.t.token=="TK_NAME"or y.t.token=="TK_STRING"then end end;function luaY:error_expected(y,z)l:syntaxerror(y,string.format(self.LUA_QS.." expected",l:token2str(y,z)))end;function luaY:errorlimit(a9,b5,b6)local A=a9.f.linedefined==0 and string.format("main function has more than %d %s",b5,b6)or string.format("function at line %d has more than %d %s",a9.f.linedefined,b5,b6)l:lexerror(a9.ls,A,0)end;function luaY:testnext(y,F)if y.t.token==F then l:next(y)return true else return false end end;function luaY:check(y,F)if y.t.token~=F then self:error_expected(y,F)end end;function luaY:checknext(y,F)self:check(y,F)l:next(y)end;function luaY:check_condition(y,F,A)if not F then l:syntaxerror(y,A)end end;function luaY:check_match(y,b6,b7,b8)if not self:testnext(y,b6)then if b8==y.linenumber then self:error_expected(y,b6)else l:syntaxerror(y,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",l:token2str(y,b6),l:token2str(y,b7),b8))end end end;function luaY:str_checkname(y)self:check(y,"TK_NAME")local R=y.t.seminfo;l:next(y)return R end;function luaY:init_exp(aa,aB,Q)aa.f,aa.t=a8.NO_JUMP,a8.NO_JUMP;aa.k=aB;aa.info=Q end;function luaY:codestring(y,aa,G)self:init_exp(aa,"VK",a8:stringK(y.fs,G))end;function luaY:checkname(y,aa)self:codestring(y,aa,self:str_checkname(y))end;function luaY:registerlocalvar(y,b9)local a9=y.fs;local aD=a9.f;self:growvector(y.L,aD.locvars,a9.nlocvars,aD.sizelocvars,nil,self.SHRT_MAX,"too many local variables")aD.locvars[a9.nlocvars]={}aD.locvars[a9.nlocvars].varname=b9;local ba=a9.nlocvars;a9.nlocvars=a9.nlocvars+1;return ba end;function luaY:new_localvarliteral(y,o,i)self:new_localvar(y,o,i)end;function luaY:new_localvar(y,g,i)local a9=y.fs;self:checklimit(a9,a9.nactvar+i+1,self.LUAI_MAXVARS,"local variables")a9.actvar[a9.nactvar+i]=self:registerlocalvar(y,g)end;function luaY:adjustlocalvars(y,bb)local a9=y.fs;a9.nactvar=a9.nactvar+bb;for Q=bb,1,-1 do self:getlocvar(a9,a9.nactvar-Q).startpc=a9.pc end end;function luaY:removevars(y,bc)local a9=y.fs;while a9.nactvar>bc do a9.nactvar=a9.nactvar-1;self:getlocvar(a9,a9.nactvar).endpc=a9.pc end end;function luaY:indexupvalue(a9,g,o)local aD=a9.f;for Q=0,aD.nups-1 do if a9.upvalues[Q].k==o.k and a9.upvalues[Q].info==o.info then assert(aD.upvalues[Q]==g)return Q end end;self:checklimit(a9,aD.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(a9.L,aD.upvalues,aD.nups,aD.sizeupvalues,nil,self.MAX_INT,"")aD.upvalues[aD.nups]=g;assert(o.k=="VLOCAL"or o.k=="VUPVAL")a9.upvalues[aD.nups]={k=o.k,info=o.info}local bd=aD.nups;aD.nups=aD.nups+1;return bd end;function luaY:searchvar(a9,i)for Q=a9.nactvar-1,0,-1 do if i==self:getlocvar(a9,Q).varname then return Q end end;return-1 end;function luaY:markupval(a9,be)local bf=a9.bl;while bf and bf.nactvar>be do bf=bf.previous end;if bf then bf.upval=true end end;function luaY:singlevaraux(a9,i,aM,b1)if a9==nil then self:init_exp(aM,"VGLOBAL",T.NO_REG)return"VGLOBAL"else local o=self:searchvar(a9,i)if o>=0 then self:init_exp(aM,"VLOCAL",o)if b1==0 then self:markupval(a9,o)end;return"VLOCAL"else if self:singlevaraux(a9.prev,i,aM,0)=="VGLOBAL"then return"VGLOBAL"end;aM.info=self:indexupvalue(a9,i,aM)aM.k="VUPVAL"return"VUPVAL"end end end;function luaY:singlevar(y,aM)local b9=self:str_checkname(y)local a9=y.fs;if self:singlevaraux(a9,b9,aM,1)=="VGLOBAL"then aM.info=a8:stringK(a9,b9)end end;function luaY:adjust_assign(y,bb,bg,aa)local a9=y.fs;local bh=bb-bg;if self:hasmultret(aa.k)then bh=bh+1;if bh<=0 then bh=0 end;a8:setreturns(a9,aa,bh)if bh>1 then a8:reserveregs(a9,bh-1)end else if aa.k~="VVOID"then a8:exp2nextreg(a9,aa)end;if bh>0 then local at=a9.freereg;a8:reserveregs(a9,bh)a8:_nil(a9,at,bh)end end end;function luaY:enterlevel(y)y.L.nCcalls=y.L.nCcalls+1;if y.L.nCcalls>self.LUAI_MAXCCALLS then l:lexerror(y,"chunk has too many syntax levels",0)end end;function luaY:leavelevel(y)y.L.nCcalls=y.L.nCcalls-1 end;function luaY:enterblock(a9,bf,bi)bf.breaklist=a8.NO_JUMP;bf.isbreakable=bi;bf.nactvar=a9.nactvar;bf.upval=false;bf.previous=a9.bl;a9.bl=bf;assert(a9.freereg==a9.nactvar)end;function luaY:leaveblock(a9)local bf=a9.bl;a9.bl=bf.previous;self:removevars(a9.ls,bf.nactvar)if bf.upval then a8:codeABC(a9,"OP_CLOSE",bf.nactvar,0,0)end;assert(not bf.isbreakable or not bf.upval)assert(bf.nactvar==a9.nactvar)a9.freereg=a9.nactvar;a8:patchtohere(a9,bf.breaklist)end;function luaY:pushclosure(y,aP,o)local a9=y.fs;local aD=a9.f;self:growvector(y.L,aD.p,a9.np,aD.sizep,nil,T.MAXARG_Bx,"constant table overflow")aD.p[a9.np]=aP.f;a9.np=a9.np+1;self:init_exp(o,"VRELOCABLE",a8:codeABx(a9,"OP_CLOSURE",0,a9.np-1))for Q=0,aP.f.nups-1 do local U=aP.upvalues[Q].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"a8:codeABC(a9,U,0,aP.upvalues[Q].info,0)end end;function luaY:open_func(y,a9)local D=y.L;local aD=self:newproto(y.L)a9.f=aD;a9.prev=y.fs;a9.ls=y;a9.L=D;y.fs=a9;a9.pc=0;a9.lasttarget=-1;a9.jpc=a8.NO_JUMP;a9.freereg=0;a9.nk=0;a9.np=0;a9.nlocvars=0;a9.nactvar=0;a9.bl=nil;aD.source=y.source;aD.maxstacksize=2;a9.h={}end;function luaY:close_func(y)local D=y.L;local a9=y.fs;local aD=a9.f;self:removevars(y,0)a8:ret(a9,0,0)aD.sizecode=a9.pc;aD.sizelineinfo=a9.pc;aD.sizek=a9.nk;aD.sizep=a9.np;aD.sizelocvars=a9.nlocvars;aD.sizeupvalues=aD.nups;assert(a9.bl==nil)y.fs=a9.prev;if a9 then self:anchor_token(y)end end;function luaY:parser(D,h,c,g)local bj={}bj.t={}bj.lookahead={}local bk={}bk.upvalues={}bk.actvar={}D.nCcalls=0;bj.buff=c;l:setinput(D,bj,h,g)self:open_func(bj,bk)bk.f.is_vararg=self.VARARG_ISVARARG;l:next(bj)self:chunk(bj)self:check(bj,"TK_EOS")self:close_func(bj)assert(bk.prev==nil)assert(bk.f.nups==0)assert(bj.fs==nil)return bk.f end;function luaY:field(y,o)local a9=y.fs;local aO={}a8:exp2anyreg(a9,o)l:next(y)self:checkname(y,aO)a8:indexed(a9,o,aO)end;function luaY:yindex(y,o)l:next(y)self:expr(y,o)a8:exp2val(y.fs,o)self:checknext(y,"]")end;function luaY:recfield(y,bl)local a9=y.fs;local at=y.fs.freereg;local aO,bm={},{}if y.t.token=="TK_NAME"then self:checklimit(a9,bl.nh,self.MAX_INT,"items in a constructor")self:checkname(y,aO)else self:yindex(y,aO)end;bl.nh=bl.nh+1;self:checknext(y,"=")local bn=a8:exp2RK(a9,aO)self:expr(y,bm)a8:codeABC(a9,"OP_SETTABLE",bl.t.info,bn,a8:exp2RK(a9,bm))a9.freereg=at end;function luaY:closelistfield(a9,bl)if bl.v.k=="VVOID"then return end;a8:exp2nextreg(a9,bl.v)bl.v.k="VVOID"if bl.tostore==T.LFIELDS_PER_FLUSH then a8:setlist(a9,bl.t.info,bl.na,bl.tostore)bl.tostore=0 end end;function luaY:lastlistfield(a9,bl)if bl.tostore==0 then return end;if self:hasmultret(bl.v.k)then a8:setmultret(a9,bl.v)a8:setlist(a9,bl.t.info,bl.na,self.LUA_MULTRET)bl.na=bl.na-1 else if bl.v.k~="VVOID"then a8:exp2nextreg(a9,bl.v)end;a8:setlist(a9,bl.t.info,bl.na,bl.tostore)end end;function luaY:listfield(y,bl)self:expr(y,bl.v)self:checklimit(y.fs,bl.na,self.MAX_INT,"items in a constructor")bl.na=bl.na+1;bl.tostore=bl.tostore+1 end;function luaY:constructor(y,a7)local a9=y.fs;local b0=y.linenumber;local al=a8:codeABC(a9,"OP_NEWTABLE",0,0,0)local bl={}bl.v={}bl.na,bl.nh,bl.tostore=0,0,0;bl.t=a7;self:init_exp(a7,"VRELOCABLE",al)self:init_exp(bl.v,"VVOID",0)a8:exp2nextreg(y.fs,a7)self:checknext(y,"{")repeat assert(bl.v.k=="VVOID"or bl.tostore>0)if y.t.token=="}"then break end;self:closelistfield(a9,bl)local F=y.t.token;if F=="TK_NAME"then l:lookahead(y)if y.lookahead.token~="="then self:listfield(y,bl)else self:recfield(y,bl)end elseif F=="["then self:recfield(y,bl)else self:listfield(y,bl)end until not self:testnext(y,",")and not self:testnext(y,";")self:check_match(y,"}","{",b0)self:lastlistfield(a9,bl)T:SETARG_B(a9.f.code[al],self:int2fb(bl.na))T:SETARG_C(a9.f.code[al],self:int2fb(bl.nh))end;function luaY:parlist(y)local a9=y.fs;local aD=a9.f;local bo=0;aD.is_vararg=0;if y.t.token~=")"then repeat local F=y.t.token;if F=="TK_NAME"then self:new_localvar(y,self:str_checkname(y),bo)bo=bo+1 elseif F=="TK_DOTS"then l:next(y)self:new_localvarliteral(y,"arg",bo)bo=bo+1;aD.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;aD.is_vararg=aD.is_vararg+self.VARARG_ISVARARG else l:syntaxerror(y,"<name> or "..self:LUA_QL("...").." expected")end until aD.is_vararg~=0 or not self:testnext(y,",")end;self:adjustlocalvars(y,bo)aD.numparams=a9.nactvar-aD.is_vararg%self.HASARG_MASK;a8:reserveregs(a9,a9.nactvar)end;function luaY:body(y,aa,bp,b0)local bq={}bq.upvalues={}bq.actvar={}self:open_func(y,bq)bq.f.lineDefined=b0;self:checknext(y,"(")if bp then self:new_localvarliteral(y,"self",0)self:adjustlocalvars(y,1)end;self:parlist(y)self:checknext(y,")")self:chunk(y)bq.f.lastlinedefined=y.linenumber;self:check_match(y,"TK_END","TK_FUNCTION",b0)self:close_func(y)self:pushclosure(y,bq,aa)end;function luaY:explist1(y,o)local i=1;self:expr(y,o)while self:testnext(y,",")do a8:exp2nextreg(y.fs,o)self:expr(y,o)i=i+1 end;return i end;function luaY:funcargs(y,aD)local a9=y.fs;local br={}local bo;local b0=y.linenumber;local F=y.t.token;if F=="("then if b0~=y.lastline then l:syntaxerror(y,"ambiguous syntax (function call x new statement)")end;l:next(y)if y.t.token==")"then br.k="VVOID"else self:explist1(y,br)a8:setmultret(a9,br)end;self:check_match(y,")","(",b0)elseif F=="{"then self:constructor(y,br)elseif F=="TK_STRING"then self:codestring(y,br,y.t.seminfo)l:next(y)else l:syntaxerror(y,"function arguments expected")return end;assert(aD.k=="VNONRELOC")local b1=aD.info;if self:hasmultret(br.k)then bo=self.LUA_MULTRET else if br.k~="VVOID"then a8:exp2nextreg(a9,br)end;bo=a9.freereg-(b1+1)end;self:init_exp(aD,"VCALL",a8:codeABC(a9,"OP_CALL",b1,bo+1,2))a8:fixline(a9,b0)a9.freereg=b1+1 end;function luaY:prefixexp(y,o)local F=y.t.token;if F=="("then local b0=y.linenumber;l:next(y)self:expr(y,o)self:check_match(y,")","(",b0)a8:dischargevars(y.fs,o)elseif F=="TK_NAME"then self:singlevar(y,o)else l:syntaxerror(y,"unexpected symbol")end;return end;function luaY:primaryexp(y,o)local a9=y.fs;self:prefixexp(y,o)while true do local F=y.t.token;if F=="."then self:field(y,o)elseif F=="["then local aO={}a8:exp2anyreg(a9,o)self:yindex(y,aO)a8:indexed(a9,o,aO)elseif F==":"then local aO={}l:next(y)self:checkname(y,aO)a8:_self(a9,o,aO)self:funcargs(y,o)elseif F=="("or F=="TK_STRING"or F=="{"then a8:exp2nextreg(a9,o)self:funcargs(y,o)else return end end end;function luaY:simpleexp(y,o)local F=y.t.token;if F=="TK_NUMBER"then self:init_exp(o,"VKNUM",0)o.nval=y.t.seminfo elseif F=="TK_STRING"then self:codestring(y,o,y.t.seminfo)elseif F=="TK_NIL"then self:init_exp(o,"VNIL",0)elseif F=="TK_TRUE"then self:init_exp(o,"VTRUE",0)elseif F=="TK_FALSE"then self:init_exp(o,"VFALSE",0)elseif F=="TK_DOTS"then local a9=y.fs;local bs=a9.f.is_vararg;if bs>=self.VARARG_NEEDSARG then a9.f.is_vararg=bs-self.VARARG_NEEDSARG end;self:init_exp(o,"VVARARG",a8:codeABC(a9,"OP_VARARG",0,1,0))elseif F=="{"then self:constructor(y,o)return elseif F=="TK_FUNCTION"then l:next(y)self:body(y,o,false,y.linenumber)return else self:primaryexp(y,o)return end;l:next(y)end;function luaY:getunopr(a4)if a4=="TK_NOT"then return"OPR_NOT"elseif a4=="-"then return"OPR_MINUS"elseif a4=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;luaY.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function luaY:getbinopr(a4)local bt=self.getbinopr_table[a4]if bt then return bt else return"OPR_NOBINOPR"end end;luaY.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}luaY.UNARY_PRIORITY=8;function luaY:subexpr(y,o,b5)self:enterlevel(y)local bu=self:getunopr(y.t.token)if bu~="OPR_NOUNOPR"then l:next(y)self:subexpr(y,o,self.UNARY_PRIORITY)a8:prefix(y.fs,bu,o)else self:simpleexp(y,o)end;local a4=self:getbinopr(y.t.token)while a4~="OPR_NOBINOPR"and self.priority[a8.BinOpr[a4]+1][1]>b5 do local aV={}l:next(y)a8:infix(y.fs,a4,o)local bv=self:subexpr(y,aV,self.priority[a8.BinOpr[a4]+1][2])a8:posfix(y.fs,a4,o,aV)a4=bv end;self:leavelevel(y)return a4 end;function luaY:expr(y,o)self:subexpr(y,o,0)end;function luaY:block_follow(z)if z=="TK_ELSE"or z=="TK_ELSEIF"or z=="TK_END"or z=="TK_UNTIL"or z=="TK_EOS"then return true else return false end end;function luaY:block(y)local a9=y.fs;local bf={}self:enterblock(a9,bf,false)self:chunk(y)assert(bf.breaklist==a8.NO_JUMP)self:leaveblock(a9)end;function luaY:check_conflict(y,bw,o)local a9=y.fs;local bh=a9.freereg;local bx=false;while bw do if bw.v.k=="VINDEXED"then if bw.v.info==o.info then bx=true;bw.v.info=bh end;if bw.v.aux==o.info then bx=true;bw.v.aux=bh end end;bw=bw.prev end;if bx then a8:codeABC(a9,"OP_MOVE",a9.freereg,o.info,0)a8:reserveregs(a9,1)end end;function luaY:assignment(y,bw,bb)local aa={}local F=bw.v.k;self:check_condition(y,F=="VLOCAL"or F=="VUPVAL"or F=="VGLOBAL"or F=="VINDEXED","syntax error")if self:testnext(y,",")then local by={}by.v={}by.prev=bw;self:primaryexp(y,by.v)if by.v.k=="VLOCAL"then self:check_conflict(y,bw,by.v)end;self:checklimit(y.fs,bb,self.LUAI_MAXCCALLS-y.L.nCcalls,"variables in assignment")self:assignment(y,by,bb+1)else self:checknext(y,"=")local bg=self:explist1(y,aa)if bg~=bb then self:adjust_assign(y,bb,bg,aa)if bg>bb then y.fs.freereg=y.fs.freereg-(bg-bb)end else a8:setoneret(y.fs,aa)a8:storevar(y.fs,bw.v,aa)return end end;self:init_exp(aa,"VNONRELOC",y.fs.freereg-1)a8:storevar(y.fs,bw.v,aa)end;function luaY:cond(y)local o={}self:expr(y,o)if o.k=="VNIL"then o.k="VFALSE"end;a8:goiftrue(y.fs,o)return o.f end;function luaY:breakstat(y)local a9=y.fs;local bf=a9.bl;local bz=false;while bf and not bf.isbreakable do if bf.upval then bz=true end;bf=bf.previous end;if not bf then l:syntaxerror(y,"no loop to break")end;if bz then a8:codeABC(a9,"OP_CLOSE",bf.nactvar,0,0)end;bf.breaklist=a8:concat(a9,bf.breaklist,a8:jump(a9))end;function luaY:whilestat(y,b0)local a9=y.fs;local bf={}l:next(y)local bA=a8:getlabel(a9)local bB=self:cond(y)self:enterblock(a9,bf,true)self:checknext(y,"TK_DO")self:block(y)a8:patchlist(a9,a8:jump(a9),bA)self:check_match(y,"TK_END","TK_WHILE",b0)self:leaveblock(a9)a8:patchtohere(a9,bB)end;function luaY:repeatstat(y,b0)local a9=y.fs;local bC=a8:getlabel(a9)local bD,bE={},{}self:enterblock(a9,bD,true)self:enterblock(a9,bE,false)l:next(y)self:chunk(y)self:check_match(y,"TK_UNTIL","TK_REPEAT",b0)local bB=self:cond(y)if not bE.upval then self:leaveblock(a9)a8:patchlist(y.fs,bB,bC)else self:breakstat(y)a8:patchtohere(y.fs,bB)self:leaveblock(a9)a8:patchlist(y.fs,a8:jump(a9),bC)end;self:leaveblock(a9)end;function luaY:exp1(y)local aa={}self:expr(y,aa)local aB=aa.k;a8:exp2nextreg(y.fs,aa)return aB end;function luaY:forbody(y,b1,b0,bb,bF)local bf={}local a9=y.fs;self:adjustlocalvars(y,3)self:checknext(y,"TK_DO")local bG=bF and a8:codeAsBx(a9,"OP_FORPREP",b1,a8.NO_JUMP)or a8:jump(a9)self:enterblock(a9,bf,false)self:adjustlocalvars(y,bb)a8:reserveregs(a9,bb)self:block(y)self:leaveblock(a9)a8:patchtohere(a9,bG)local bH=bF and a8:codeAsBx(a9,"OP_FORLOOP",b1,a8.NO_JUMP)or a8:codeABC(a9,"OP_TFORLOOP",b1,0,bb)a8:fixline(a9,b0)a8:patchlist(a9,bF and bH or a8:jump(a9),bG+1)end;function luaY:fornum(y,b9,b0)local a9=y.fs;local b1=a9.freereg;self:new_localvarliteral(y,"(for index)",0)self:new_localvarliteral(y,"(for limit)",1)self:new_localvarliteral(y,"(for step)",2)self:new_localvar(y,b9,3)self:checknext(y,'=')self:exp1(y)self:checknext(y,",")self:exp1(y)if self:testnext(y,",")then self:exp1(y)else a8:codeABx(a9,"OP_LOADK",a9.freereg,a8:numberK(a9,1))a8:reserveregs(a9,1)end;self:forbody(y,b1,b0,1,true)end;function luaY:forlist(y,bI)local a9=y.fs;local aa={}local bb=0;local b1=a9.freereg;self:new_localvarliteral(y,"(for generator)",bb)bb=bb+1;self:new_localvarliteral(y,"(for state)",bb)bb=bb+1;self:new_localvarliteral(y,"(for control)",bb)bb=bb+1;self:new_localvar(y,bI,bb)bb=bb+1;while self:testnext(y,",")do self:new_localvar(y,self:str_checkname(y),bb)bb=bb+1 end;self:checknext(y,"TK_IN")local b0=y.linenumber;self:adjust_assign(y,3,self:explist1(y,aa),aa)a8:checkstack(a9,3)self:forbody(y,b1,b0,bb-3,false)end;function luaY:forstat(y,b0)local a9=y.fs;local bf={}self:enterblock(a9,bf,true)l:next(y)local b9=self:str_checkname(y)local F=y.t.token;if F=="="then self:fornum(y,b9,b0)elseif F==","or F=="TK_IN"then self:forlist(y,b9)else l:syntaxerror(y,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(y,"TK_END","TK_FOR",b0)self:leaveblock(a9)end;function luaY:test_then_block(y)l:next(y)local bB=self:cond(y)self:checknext(y,"TK_THEN")self:block(y)return bB end;function luaY:ifstat(y,b0)local a9=y.fs;local bJ=a8.NO_JUMP;local bK=self:test_then_block(y)while y.t.token=="TK_ELSEIF"do bJ=a8:concat(a9,bJ,a8:jump(a9))a8:patchtohere(a9,bK)bK=self:test_then_block(y)end;if y.t.token=="TK_ELSE"then bJ=a8:concat(a9,bJ,a8:jump(a9))a8:patchtohere(a9,bK)l:next(y)self:block(y)else bJ=a8:concat(a9,bJ,bK)end;a8:patchtohere(a9,bJ)self:check_match(y,"TK_END","TK_IF",b0)end;function luaY:localfunc(y)local o,d={},{}local a9=y.fs;self:new_localvar(y,self:str_checkname(y),0)self:init_exp(o,"VLOCAL",a9.freereg)a8:reserveregs(a9,1)self:adjustlocalvars(y,1)self:body(y,d,false,y.linenumber)a8:storevar(a9,o,d)self:getlocvar(a9,a9.nactvar-1).startpc=a9.pc end;function luaY:localstat(y)local bb=0;local bg;local aa={}repeat self:new_localvar(y,self:str_checkname(y),bb)bb=bb+1 until not self:testnext(y,",")if self:testnext(y,"=")then bg=self:explist1(y,aa)else aa.k="VVOID"bg=0 end;self:adjust_assign(y,bb,bg,aa)self:adjustlocalvars(y,bb)end;function luaY:funcname(y,o)local bp=false;self:singlevar(y,o)while y.t.token=="."do self:field(y,o)end;if y.t.token==":"then bp=true;self:field(y,o)end;return bp end;function luaY:funcstat(y,b0)local o,d={},{}l:next(y)local bp=self:funcname(y,o)self:body(y,d,bp,b0)a8:storevar(y.fs,o,d)a8:fixline(y.fs,b0)end;function luaY:exprstat(y)local a9=y.fs;local o={}o.v={}self:primaryexp(y,o.v)if o.v.k=="VCALL"then T:SETARG_C(a8:getcode(a9,o.v),1)else o.prev=nil;self:assignment(y,o,1)end end;function luaY:retstat(y)local a9=y.fs;local aa={}local v,ai;l:next(y)if self:block_follow(y.t.token)or y.t.token==";"then v,ai=0,0 else ai=self:explist1(y,aa)if self:hasmultret(aa.k)then a8:setmultret(a9,aa)if aa.k=="VCALL"and ai==1 then T:SET_OPCODE(a8:getcode(a9,aa),"OP_TAILCALL")assert(T:GETARG_A(a8:getcode(a9,aa))==a9.nactvar)end;v=a9.nactvar;ai=self.LUA_MULTRET else if ai==1 then v=a8:exp2anyreg(a9,aa)else a8:exp2nextreg(a9,aa)v=a9.nactvar;assert(ai==a9.freereg-v)end end end;a8:ret(a9,v,ai)end;function luaY:statement(y)local b0=y.linenumber;local F=y.t.token;if F=="TK_IF"then self:ifstat(y,b0)return false elseif F=="TK_WHILE"then self:whilestat(y,b0)return false elseif F=="TK_DO"then l:next(y)self:block(y)self:check_match(y,"TK_END","TK_DO",b0)return false elseif F=="TK_FOR"then self:forstat(y,b0)return false elseif F=="TK_REPEAT"then self:repeatstat(y,b0)return false elseif F=="TK_FUNCTION"then self:funcstat(y,b0)return false elseif F=="TK_LOCAL"then l:next(y)if self:testnext(y,"TK_FUNCTION")then self:localfunc(y)else self:localstat(y)end;return false elseif F=="TK_RETURN"then self:retstat(y)return true elseif F=="TK_BREAK"then l:next(y)self:breakstat(y)return true else self:exprstat(y)return false end end;function luaY:chunk(y)local bL=false;self:enterlevel(y)while not bL and not self:block_follow(y.t.token)do bL=self:statement(y)self:testnext(y,";")assert(y.fs.f.maxstacksize>=y.fs.freereg and y.fs.freereg>=y.fs.nactvar)y.fs.freereg=y.fs.nactvar end;self:leavelevel(y)end;return luaY end;local bM=a.luy()function a.luu()local bN={}local T=a.lup()bN.LUA_SIGNATURE="\27Lua"bN.LUA_TNUMBER=3;bN.LUA_TSTRING=4;bN.LUA_TNIL=0;bN.LUA_TBOOLEAN=1;bN.LUA_TNONE=-1;bN.LUAC_VERSION=0x51;bN.LUAC_FORMAT=0;bN.LUAC_HEADERSIZE=12;function bN:make_setS()local c={}c.data=""local bO=function(G,c)if not G then return 0 end;c.data=c.data..G;return 0 end;return bO,c end;function bN:ttype(U)local bP=type(U.value)if bP=="number"then return self.LUA_TNUMBER elseif bP=="string"then return self.LUA_TSTRING elseif bP=="nil"then return self.LUA_TNIL elseif bP=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function bN:from_double(a2)local function bQ(o)local F=o%256;return(o-F)/256,string.char(F)end;local bR=0;if a2<0 then bR=1;a2=-a2 end;local bS,bT=math.frexp(a2)if a2==0 then bS,bT=0,0 elseif a2==1/0 then bS,bT=0,2047 else bS=(bS*2-1)*math.ldexp(0.5,53)bT=bT+1022 end;local o,a3=""a2=math.floor(bS)for Q=1,6 do a2,a3=bQ(a2)o=o..a3 end;a2,a3=bQ(bT*16+a2)o=o..a3;a2,a3=bQ(bR*128+a2)o=o..a3;return o end;function bN:from_int(a2)local o=""a2=math.floor(a2)if a2<0 then a2=4294967296+a2 end;for Q=1,4 do local F=a2%256;o=o..string.char(F)a2=math.floor(a2/256)end;return o end;function bN:DumpBlock(d,bU)if bU.status==0 then bU.status=bU.write(d,bU.data)end end;function bN:DumpChar(bV,bU)self:DumpBlock(string.char(bV),bU)end;function bN:DumpInt(a2,bU)self:DumpBlock(self:from_int(a2),bU)end;function bN:DumpNumber(a2,bU)self:DumpBlock(self:from_double(a2),bU)end;function bN:DumpString(G,bU)if G==nil then self:DumpInt(0,bU)else G=G.."\0"self:DumpInt(#G,bU)self:DumpBlock(G,bU)end end;function bN:DumpCode(aD,bU)local i=aD.sizecode;self:DumpInt(i,bU)for Q=0,i-1 do self:DumpBlock(T:Instruction(aD.code[Q]),bU)end end;function bN:DumpConstants(aD,bU)local i=aD.sizek;self:DumpInt(i,bU)for Q=0,i-1 do local U=aD.k[Q]local bP=self:ttype(U)self:DumpChar(bP,bU)if bP==self.LUA_TNIL then elseif bP==self.LUA_TBOOLEAN then self:DumpChar(U.value and 1 or 0,bU)elseif bP==self.LUA_TNUMBER then self:DumpNumber(U.value,bU)elseif bP==self.LUA_TSTRING then self:DumpString(U.value,bU)else end end;i=aD.sizep;self:DumpInt(i,bU)for Q=0,i-1 do self:DumpFunction(aD.p[Q],aD.source,bU)end end;function bN:DumpDebug(aD,bU)local i;i=bU.strip and 0 or aD.sizelineinfo;self:DumpInt(i,bU)for Q=0,i-1 do self:DumpInt(aD.lineinfo[Q],bU)end;i=bU.strip and 0 or aD.sizelocvars;self:DumpInt(i,bU)for Q=0,i-1 do self:DumpString(aD.locvars[Q].varname,bU)self:DumpInt(aD.locvars[Q].startpc,bU)self:DumpInt(aD.locvars[Q].endpc,bU)end;i=bU.strip and 0 or aD.sizeupvalues;self:DumpInt(i,bU)for Q=0,i-1 do self:DumpString(aD.upvalues[Q],bU)end end;function bN:DumpFunction(aD,j,bU)local s=aD.source;if s==j or bU.strip then s=nil end;self:DumpString(s,bU)self:DumpInt(aD.lineDefined,bU)self:DumpInt(aD.lastlinedefined,bU)self:DumpChar(aD.nups,bU)self:DumpChar(aD.numparams,bU)self:DumpChar(aD.is_vararg,bU)self:DumpChar(aD.maxstacksize,bU)self:DumpCode(aD,bU)self:DumpConstants(aD,bU)self:DumpDebug(aD,bU)end;function bN:DumpHeader(bU)local bW=self:header()assert(#bW==self.LUAC_HEADERSIZE)self:DumpBlock(bW,bU)end;function bN:header()local a2=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,a2,4,4,4,8,0)end;function bN:dump(D,aD,bX,e,bY)local bU={}bU.L=D;bU.write=bX;bU.data=e;bU.strip=bY;bU.status=0;self:DumpHeader(bU)self:DumpFunction(aD,nil,bU)bU.write(nil,bU.data)return bU.status end;return bN end;local bZ=a.luu()S:init()local b_={}getfenv().script=nil;local c0=function(r,c1)local aD,bO,c,g;local c1=c1 or getfenv(2)local g=nil;local c2,error=pcall(function()local c3=k:init(k:make_getS(r),nil)local aP=bM:parser(b_,c3,nil,g or"nil")bO,c=bZ:make_setS()bZ:dump(b_,aP,bO,c)end)if c2 then local X=c.data; return X end end;
	
	
	
	
